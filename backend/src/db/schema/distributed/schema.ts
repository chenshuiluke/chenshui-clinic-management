/**
 * Distributed Database Schema
 * Auto-generated by drizzle-kit pull and manually refined
 *
 * This schema defines tables in organization-specific databases (e.g., clinic_acme):
 * - organization_user: Users within an organization with role-based profile
 * - admin_profile: Administrative user profile
 * - doctor_profile: Doctor user profile
 * - patient_profile: Patient user profile
 * - appointment: Appointments between patients and doctors
 */

import { pgTable, serial, varchar, timestamp, foreignKey, unique, check, integer, text, index, pgEnum } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

/**
 * Appointment status enum
 * Defines the lifecycle states of an appointment
 */
export const appointmentStatus = pgEnum("appointment_status", ['PENDING', 'APPROVED', 'DECLINED', 'COMPLETED', 'CANCELLED'])

/**
 * Admin profile table
 * Minimal profile for administrative users
 */
export const adminProfileTable = pgTable("admin_profile", {
	id: serial().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'date' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'date' }),
});

/**
 * Doctor profile table
 * Contains doctor-specific information
 */
export const doctorProfileTable = pgTable("doctor_profile", {
	id: serial().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'date' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'date' }),
	specialization: varchar({ length: 255 }).default('').notNull(),
	licenseNumber: varchar("license_number", { length: 255 }).default('').notNull(),
	phoneNumber: varchar("phone_number", { length: 255 }),
});

/**
 * Patient profile table
 * Contains patient-specific medical and contact information
 */
export const patientProfileTable = pgTable("patient_profile", {
	id: serial().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'date' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'date' }),
	dateOfBirth: timestamp("date_of_birth", { withTimezone: true, mode: 'date' }).notNull(),
	phoneNumber: varchar("phone_number", { length: 255 }).default('').notNull(),
	address: varchar({ length: 255 }),
	emergencyContactName: varchar("emergency_contact_name", { length: 255 }),
	emergencyContactPhone: varchar("emergency_contact_phone", { length: 255 }),
	bloodType: varchar("blood_type", { length: 255 }),
	allergies: varchar({ length: 255 }),
	chronicConditions: varchar("chronic_conditions", { length: 255 }),
	ipAddress: varchar("ip_address", { length: 255 }).default('').notNull(),
});

/**
 * Organization user table
 * Users within an organization with exactly one role (admin, doctor, or patient)
 * The check_only_one_role constraint ensures exactly one profile is set
 */
export const organizationUserTable = pgTable("organization_user", {
	id: serial().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'date' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'date' }),
	email: varchar({ length: 255 }).notNull(),
	password: varchar({ length: 255 }).notNull(),
	firstName: varchar("first_name", { length: 255 }).notNull(),
	lastName: varchar("last_name", { length: 255 }).notNull(),
	doctorProfileId: integer("doctor_profile_id"),
	patientProfileId: integer("patient_profile_id"),
	adminProfileId: integer("admin_profile_id"),
	refreshToken: text("refresh_token"),
}, (table) => {
	return {
		organizationUserDoctorProfileIdForeign: foreignKey({
			columns: [table.doctorProfileId],
			foreignColumns: [doctorProfileTable.id],
			name: "organization_user_doctor_profile_id_foreign"
		}).onUpdate("cascade").onDelete("set null"),
		organizationUserPatientProfileIdForeign: foreignKey({
			columns: [table.patientProfileId],
			foreignColumns: [patientProfileTable.id],
			name: "organization_user_patient_profile_id_foreign"
		}).onUpdate("cascade").onDelete("set null"),
		organizationUserAdminProfileIdForeign: foreignKey({
			columns: [table.adminProfileId],
			foreignColumns: [adminProfileTable.id],
			name: "organization_user_admin_profile_id_foreign"
		}).onUpdate("cascade").onDelete("set null"),
		organizationUserEmailUnique: unique("organization_user_email_unique").on(table.email),
		organizationUserDoctorProfileIdUnique: unique("organization_user_doctor_profile_id_unique").on(table.doctorProfileId),
		organizationUserPatientProfileIdUnique: unique("organization_user_patient_profile_id_unique").on(table.patientProfileId),
		organizationUserAdminProfileIdUnique: unique("organization_user_admin_profile_id_unique").on(table.adminProfileId),
		checkOnlyOneRole: check("check_only_one_role", sql`((patient_profile_id IS NOT NULL) AND (doctor_profile_id IS NULL) AND (admin_profile_id IS NULL)) OR ((patient_profile_id IS NULL) AND (doctor_profile_id IS NOT NULL) AND (admin_profile_id IS NULL)) OR ((patient_profile_id IS NULL) AND (doctor_profile_id IS NULL) AND (admin_profile_id IS NOT NULL)) OR ((patient_profile_id IS NULL) AND (doctor_profile_id IS NULL) AND (admin_profile_id IS NULL))`),
	}
});

/**
 * Appointment table
 * Appointments between patients and doctors with status tracking
 * Both patient and doctor references are nullable to allow for soft deletion
 */
export const appointmentTable = pgTable("appointment", {
	id: serial().primaryKey().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'date' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'date' }),
	patientId: integer("patient_id"),
	doctorId: integer("doctor_id"),
	appointmentDateTime: timestamp("appointment_date_time", { withTimezone: true, mode: 'date' }).notNull(),
	status: appointmentStatus().default('PENDING').notNull(),
	notes: text(),
}, (table) => {
	return {
		doctorIdIdx: index().using("btree", table.doctorId.asc().nullsLast().op("int4_ops")),
		patientIdIdx: index().using("btree", table.patientId.asc().nullsLast().op("int4_ops")),
		appointmentPatientIdForeign: foreignKey({
			columns: [table.patientId],
			foreignColumns: [organizationUserTable.id],
			name: "appointment_patient_id_foreign"
		}).onUpdate("cascade").onDelete("set null"),
		appointmentDoctorIdForeign: foreignKey({
			columns: [table.doctorId],
			foreignColumns: [organizationUserTable.id],
			name: "appointment_doctor_id_foreign"
		}).onUpdate("cascade").onDelete("set null"),
	}
});
